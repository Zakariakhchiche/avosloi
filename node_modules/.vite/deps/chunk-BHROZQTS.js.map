{
  "version": 3,
  "sources": ["../../langchain/dist/stores/message/in_memory.js", "../../langchain/dist/memory/chat_memory.js", "../../langchain/dist/memory/buffer_memory.js"],
  "sourcesContent": ["import { BaseListChatMessageHistory } from \"../../schema/index.js\";\r\n/**\r\n * Class for storing chat message history in-memory. It extends the\r\n * BaseListChatMessageHistory class and provides methods to get, add, and\r\n * clear messages.\r\n */\r\nexport class ChatMessageHistory extends BaseListChatMessageHistory {\r\n    constructor(messages) {\r\n        super(...arguments);\r\n        Object.defineProperty(this, \"lc_namespace\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: [\"langchain\", \"stores\", \"message\", \"in_memory\"]\r\n        });\r\n        Object.defineProperty(this, \"messages\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: []\r\n        });\r\n        this.messages = messages ?? [];\r\n    }\r\n    /**\r\n     * Method to get all the messages stored in the ChatMessageHistory\r\n     * instance.\r\n     * @returns Array of stored BaseMessage instances.\r\n     */\r\n    async getMessages() {\r\n        return this.messages;\r\n    }\r\n    /**\r\n     * Method to add a new message to the ChatMessageHistory instance.\r\n     * @param message The BaseMessage instance to add.\r\n     * @returns A promise that resolves when the message has been added.\r\n     */\r\n    async addMessage(message) {\r\n        this.messages.push(message);\r\n    }\r\n    /**\r\n     * Method to clear all the messages from the ChatMessageHistory instance.\r\n     * @returns A promise that resolves when all messages have been cleared.\r\n     */\r\n    async clear() {\r\n        this.messages = [];\r\n    }\r\n}\r\n", "import { BaseMemory, getInputValue, getOutputValue, } from \"./base.js\";\r\nimport { ChatMessageHistory } from \"../stores/message/in_memory.js\";\r\n/**\r\n * Abstract class that provides a base for implementing different types of\r\n * memory systems. It is designed to maintain the state of an application,\r\n * specifically the history of a conversation. This class is typically\r\n * extended by other classes to create specific types of memory systems.\r\n */\r\nexport class BaseChatMemory extends BaseMemory {\r\n    constructor(fields) {\r\n        super();\r\n        Object.defineProperty(this, \"chatHistory\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"returnMessages\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: false\r\n        });\r\n        Object.defineProperty(this, \"inputKey\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"outputKey\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        this.chatHistory = fields?.chatHistory ?? new ChatMessageHistory();\r\n        this.returnMessages = fields?.returnMessages ?? this.returnMessages;\r\n        this.inputKey = fields?.inputKey ?? this.inputKey;\r\n        this.outputKey = fields?.outputKey ?? this.outputKey;\r\n    }\r\n    /**\r\n     * Method to add user and AI messages to the chat history in sequence.\r\n     * @param inputValues The input values from the user.\r\n     * @param outputValues The output values from the AI.\r\n     * @returns Promise that resolves when the context has been saved.\r\n     */\r\n    async saveContext(inputValues, outputValues) {\r\n        // this is purposefully done in sequence so they're saved in order\r\n        await this.chatHistory.addUserMessage(getInputValue(inputValues, this.inputKey));\r\n        await this.chatHistory.addAIChatMessage(getOutputValue(outputValues, this.outputKey));\r\n    }\r\n    /**\r\n     * Method to clear the chat history.\r\n     * @returns Promise that resolves when the chat history has been cleared.\r\n     */\r\n    async clear() {\r\n        await this.chatHistory.clear();\r\n    }\r\n}\r\n", "import { getBufferString } from \"./base.js\";\r\nimport { BaseChatMemory } from \"./chat_memory.js\";\r\n/**\r\n * The `BufferMemory` class is a type of memory component used for storing\r\n * and managing previous chat messages. It is a wrapper around\r\n * `ChatMessageHistory` that extracts the messages into an input variable.\r\n * This class is particularly useful in applications like chatbots where\r\n * it is essential to remember previous interactions. Note: The memory\r\n * instance represents the history of a single conversation. Therefore, it\r\n * is not recommended to share the same history or memory instance between\r\n * two different chains. If you deploy your LangChain app on a serverless\r\n * environment, do not store memory instances in a variable, as your\r\n * hosting provider may reset it by the next time the function is called.\r\n */\r\nexport class BufferMemory extends BaseChatMemory {\r\n    constructor(fields) {\r\n        super({\r\n            chatHistory: fields?.chatHistory,\r\n            returnMessages: fields?.returnMessages ?? false,\r\n            inputKey: fields?.inputKey,\r\n            outputKey: fields?.outputKey,\r\n        });\r\n        Object.defineProperty(this, \"humanPrefix\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: \"Human\"\r\n        });\r\n        Object.defineProperty(this, \"aiPrefix\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: \"AI\"\r\n        });\r\n        Object.defineProperty(this, \"memoryKey\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: \"history\"\r\n        });\r\n        this.humanPrefix = fields?.humanPrefix ?? this.humanPrefix;\r\n        this.aiPrefix = fields?.aiPrefix ?? this.aiPrefix;\r\n        this.memoryKey = fields?.memoryKey ?? this.memoryKey;\r\n    }\r\n    get memoryKeys() {\r\n        return [this.memoryKey];\r\n    }\r\n    /**\r\n     * Loads the memory variables. It takes an `InputValues` object as a\r\n     * parameter and returns a `Promise` that resolves with a\r\n     * `MemoryVariables` object.\r\n     * @param _values `InputValues` object.\r\n     * @returns A `Promise` that resolves with a `MemoryVariables` object.\r\n     */\r\n    async loadMemoryVariables(_values) {\r\n        const messages = await this.chatHistory.getMessages();\r\n        if (this.returnMessages) {\r\n            const result = {\r\n                [this.memoryKey]: messages,\r\n            };\r\n            return result;\r\n        }\r\n        const result = {\r\n            [this.memoryKey]: getBufferString(messages, this.humanPrefix, this.aiPrefix),\r\n        };\r\n        return result;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["result"]
}
