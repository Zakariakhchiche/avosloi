{
  "version": 3,
  "sources": ["../../langchain/dist/schema/output_parser.js", "../../langchain/dist/output_parsers/noop.js", "../../langchain/dist/chains/llm_chain.js"],
  "sourcesContent": ["import { Runnable } from \"./runnable/index.js\";\r\n/**\r\n * Abstract base class for parsing the output of a Large Language Model\r\n * (LLM) call. It provides methods for parsing the result of an LLM call\r\n * and invoking the parser with a given input.\r\n */\r\nexport class BaseLLMOutputParser extends Runnable {\r\n    /**\r\n     * Parses the result of an LLM call with a given prompt. By default, it\r\n     * simply calls `parseResult`.\r\n     * @param generations The generations from an LLM call.\r\n     * @param _prompt The prompt used in the LLM call.\r\n     * @param callbacks Optional callbacks.\r\n     * @returns A promise of the parsed output.\r\n     */\r\n    parseResultWithPrompt(generations, _prompt, callbacks) {\r\n        return this.parseResult(generations, callbacks);\r\n    }\r\n    /**\r\n     * Calls the parser with a given input and optional configuration options.\r\n     * If the input is a string, it creates a generation with the input as\r\n     * text and calls `parseResult`. If the input is a `BaseMessage`, it\r\n     * creates a generation with the input as a message and the content of the\r\n     * input as text, and then calls `parseResult`.\r\n     * @param input The input to the parser, which can be a string or a `BaseMessage`.\r\n     * @param options Optional configuration options.\r\n     * @returns A promise of the parsed output.\r\n     */\r\n    async invoke(input, options) {\r\n        if (typeof input === \"string\") {\r\n            return this._callWithConfig(async (input) => this.parseResult([{ text: input }]), input, { ...options, runType: \"parser\" });\r\n        }\r\n        else {\r\n            return this._callWithConfig(async (input) => this.parseResult([{ message: input, text: input.content }]), input, { ...options, runType: \"parser\" });\r\n        }\r\n    }\r\n}\r\n/**\r\n * Class to parse the output of an LLM call.\r\n */\r\nexport class BaseOutputParser extends BaseLLMOutputParser {\r\n    parseResult(generations, callbacks) {\r\n        return this.parse(generations[0].text, callbacks);\r\n    }\r\n    async parseWithPrompt(text, _prompt, callbacks) {\r\n        return this.parse(text, callbacks);\r\n    }\r\n    /**\r\n     * Return the string type key uniquely identifying this class of parser\r\n     */\r\n    _type() {\r\n        throw new Error(\"_type not implemented\");\r\n    }\r\n}\r\n/**\r\n * Class to parse the output of an LLM call that also allows streaming inputs.\r\n */\r\nexport class BaseTransformOutputParser extends BaseOutputParser {\r\n    async *_transform(inputGenerator) {\r\n        for await (const chunk of inputGenerator) {\r\n            if (typeof chunk === \"string\") {\r\n                yield this.parseResult([{ text: chunk }]);\r\n            }\r\n            else {\r\n                yield this.parseResult([{ message: chunk, text: chunk.content }]);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Transforms an asynchronous generator of input into an asynchronous\r\n     * generator of parsed output.\r\n     * @param inputGenerator An asynchronous generator of input.\r\n     * @param options A configuration object.\r\n     * @returns An asynchronous generator of parsed output.\r\n     */\r\n    async *transform(inputGenerator, options) {\r\n        yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {\r\n            ...options,\r\n            runType: \"parser\",\r\n        });\r\n    }\r\n}\r\n/**\r\n * OutputParser that parses LLMResult into the top likely string.\r\n */\r\nexport class StringOutputParser extends BaseTransformOutputParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        Object.defineProperty(this, \"lc_namespace\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: [\"langchain\", \"schema\", \"output_parser\"]\r\n        });\r\n        Object.defineProperty(this, \"lc_serializable\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: true\r\n        });\r\n    }\r\n    static lc_name() {\r\n        return \"StrOutputParser\";\r\n    }\r\n    /**\r\n     * Parses a string output from an LLM call. This method is meant to be\r\n     * implemented by subclasses to define how a string output from an LLM\r\n     * should be parsed.\r\n     * @param text The string output from an LLM call.\r\n     * @param callbacks Optional callbacks.\r\n     * @returns A promise of the parsed output.\r\n     */\r\n    parse(text) {\r\n        return Promise.resolve(text);\r\n    }\r\n    getFormatInstructions() {\r\n        return \"\";\r\n    }\r\n}\r\n/**\r\n * OutputParser that parses LLMResult into the top likely string and\r\n * encodes it into bytes.\r\n */\r\nexport class BytesOutputParser extends BaseTransformOutputParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        Object.defineProperty(this, \"lc_namespace\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: [\"langchain\", \"schema\", \"output_parser\"]\r\n        });\r\n        Object.defineProperty(this, \"lc_serializable\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: true\r\n        });\r\n        Object.defineProperty(this, \"textEncoder\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: new TextEncoder()\r\n        });\r\n    }\r\n    static lc_name() {\r\n        return \"BytesOutputParser\";\r\n    }\r\n    parse(text) {\r\n        return Promise.resolve(this.textEncoder.encode(text));\r\n    }\r\n    getFormatInstructions() {\r\n        return \"\";\r\n    }\r\n}\r\n/**\r\n * Exception that output parsers should raise to signify a parsing error.\r\n *\r\n * This exists to differentiate parsing errors from other code or execution errors\r\n * that also may arise inside the output parser. OutputParserExceptions will be\r\n * available to catch and handle in ways to fix the parsing error, while other\r\n * errors will be raised.\r\n *\r\n * @param message - The error that's being re-raised or an error message.\r\n * @param llmOutput - String model output which is error-ing.\r\n * @param observation - String explanation of error which can be passed to a\r\n *     model to try and remediate the issue.\r\n * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\r\n *     after an OutputParserException has been raised. This gives the underlying\r\n *     model driving the agent the context that the previous output was improperly\r\n *     structured, in the hopes that it will update the output to the correct\r\n *     format.\r\n */\r\nexport class OutputParserException extends Error {\r\n    constructor(message, llmOutput, observation, sendToLLM = false) {\r\n        super(message);\r\n        Object.defineProperty(this, \"llmOutput\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"observation\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"sendToLLM\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        this.llmOutput = llmOutput;\r\n        this.observation = observation;\r\n        this.sendToLLM = sendToLLM;\r\n        if (sendToLLM) {\r\n            if (observation === undefined || llmOutput === undefined) {\r\n                throw new Error(\"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\");\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { BaseOutputParser } from \"../schema/output_parser.js\";\r\n/**\r\n * The NoOpOutputParser class is a type of output parser that does not\r\n * perform any operations on the output. It extends the BaseOutputParser\r\n * class and is part of the LangChain's output parsers module. This class\r\n * is useful in scenarios where the raw output of the Large Language\r\n * Models (LLMs) is required.\r\n */\r\nexport class NoOpOutputParser extends BaseOutputParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        Object.defineProperty(this, \"lc_namespace\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: [\"langchain\", \"output_parsers\", \"default\"]\r\n        });\r\n        Object.defineProperty(this, \"lc_serializable\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: true\r\n        });\r\n    }\r\n    static lc_name() {\r\n        return \"NoOpOutputParser\";\r\n    }\r\n    /**\r\n     * This method takes a string as input and returns the same string as\r\n     * output. It does not perform any operations on the input string.\r\n     * @param text The input string to be parsed.\r\n     * @returns The same input string without any operations performed on it.\r\n     */\r\n    parse(text) {\r\n        return Promise.resolve(text);\r\n    }\r\n    /**\r\n     * This method returns an empty string. It does not provide any formatting\r\n     * instructions.\r\n     * @returns An empty string, indicating no formatting instructions.\r\n     */\r\n    getFormatInstructions() {\r\n        return \"\";\r\n    }\r\n}\r\n", "import { BaseChain } from \"./base.js\";\r\nimport { BasePromptTemplate } from \"../prompts/base.js\";\r\nimport { BaseLanguageModel } from \"../base_language/index.js\";\r\nimport { NoOpOutputParser } from \"../output_parsers/noop.js\";\r\n/**\r\n * Chain to run queries against LLMs.\r\n *\r\n * @example\r\n * ```ts\r\n * import { LLMChain } from \"langchain/chains\";\r\n * import { OpenAI } from \"langchain/llms/openai\";\r\n * import { PromptTemplate } from \"langchain/prompts\";\r\n *\r\n * const prompt = PromptTemplate.fromTemplate(\"Tell me a {adjective} joke\");\r\n * const llm = new LLMChain({ llm: new OpenAI(), prompt });\r\n * ```\r\n */\r\nexport class LLMChain extends BaseChain {\r\n    static lc_name() {\r\n        return \"LLMChain\";\r\n    }\r\n    get inputKeys() {\r\n        return this.prompt.inputVariables;\r\n    }\r\n    get outputKeys() {\r\n        return [this.outputKey];\r\n    }\r\n    constructor(fields) {\r\n        super(fields);\r\n        Object.defineProperty(this, \"lc_serializable\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: true\r\n        });\r\n        Object.defineProperty(this, \"prompt\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"llm\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"llmKwargs\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"outputKey\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: \"text\"\r\n        });\r\n        Object.defineProperty(this, \"outputParser\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        this.prompt = fields.prompt;\r\n        this.llm = fields.llm;\r\n        this.llmKwargs = fields.llmKwargs;\r\n        this.outputKey = fields.outputKey ?? this.outputKey;\r\n        this.outputParser =\r\n            fields.outputParser ?? new NoOpOutputParser();\r\n        if (this.prompt.outputParser) {\r\n            if (fields.outputParser) {\r\n                throw new Error(\"Cannot set both outputParser and prompt.outputParser\");\r\n            }\r\n            this.outputParser = this.prompt.outputParser;\r\n        }\r\n    }\r\n    /** @ignore */\r\n    _selectMemoryInputs(values) {\r\n        const valuesForMemory = super._selectMemoryInputs(values);\r\n        for (const key of this.llm.callKeys) {\r\n            if (key in values) {\r\n                delete valuesForMemory[key];\r\n            }\r\n        }\r\n        return valuesForMemory;\r\n    }\r\n    /** @ignore */\r\n    async _getFinalOutput(generations, promptValue, runManager) {\r\n        let finalCompletion;\r\n        if (this.outputParser) {\r\n            finalCompletion = await this.outputParser.parseResultWithPrompt(generations, promptValue, runManager?.getChild());\r\n        }\r\n        else {\r\n            finalCompletion = generations[0].text;\r\n        }\r\n        return finalCompletion;\r\n    }\r\n    /**\r\n     * Run the core logic of this chain and add to output if desired.\r\n     *\r\n     * Wraps _call and handles memory.\r\n     */\r\n    call(values, config) {\r\n        return super.call(values, config);\r\n    }\r\n    /** @ignore */\r\n    async _call(values, runManager) {\r\n        const valuesForPrompt = { ...values };\r\n        const valuesForLLM = {\r\n            ...this.llmKwargs,\r\n        };\r\n        for (const key of this.llm.callKeys) {\r\n            if (key in values) {\r\n                valuesForLLM[key] = values[key];\r\n                delete valuesForPrompt[key];\r\n            }\r\n        }\r\n        const promptValue = await this.prompt.formatPromptValue(valuesForPrompt);\r\n        const { generations } = await this.llm.generatePrompt([promptValue], valuesForLLM, runManager?.getChild());\r\n        return {\r\n            [this.outputKey]: await this._getFinalOutput(generations[0], promptValue, runManager),\r\n        };\r\n    }\r\n    /**\r\n     * Format prompt with values and pass to LLM\r\n     *\r\n     * @param values - keys to pass to prompt template\r\n     * @param callbackManager - CallbackManager to use\r\n     * @returns Completion from LLM.\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * llm.predict({ adjective: \"funny\" })\r\n     * ```\r\n     */\r\n    async predict(values, callbackManager) {\r\n        const output = await this.call(values, callbackManager);\r\n        return output[this.outputKey];\r\n    }\r\n    _chainType() {\r\n        return \"llm\";\r\n    }\r\n    static async deserialize(data) {\r\n        const { llm, prompt } = data;\r\n        if (!llm) {\r\n            throw new Error(\"LLMChain must have llm\");\r\n        }\r\n        if (!prompt) {\r\n            throw new Error(\"LLMChain must have prompt\");\r\n        }\r\n        return new LLMChain({\r\n            llm: await BaseLanguageModel.deserialize(llm),\r\n            prompt: await BasePromptTemplate.deserialize(prompt),\r\n        });\r\n    }\r\n    /** @deprecated */\r\n    serialize() {\r\n        return {\r\n            _type: `${this._chainType()}_chain`,\r\n            llm: this.llm.serialize(),\r\n            prompt: this.prompt.serialize(),\r\n        };\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["input"]
}
