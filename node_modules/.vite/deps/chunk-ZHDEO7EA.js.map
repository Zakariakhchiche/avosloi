{
  "version": 3,
  "sources": ["../../langchain/dist/util/set.js", "../../langchain/dist/chains/sequential_chain.js"],
  "sourcesContent": ["/**\r\n * Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#implementing_basic_set_operations\r\n */\r\n/**\r\n * returns intersection of two sets\r\n */\r\nexport function intersection(setA, setB) {\r\n    const _intersection = new Set();\r\n    for (const elem of setB) {\r\n        if (setA.has(elem)) {\r\n            _intersection.add(elem);\r\n        }\r\n    }\r\n    return _intersection;\r\n}\r\n/**\r\n * returns union of two sets\r\n */\r\nexport function union(setA, setB) {\r\n    const _union = new Set(setA);\r\n    for (const elem of setB) {\r\n        _union.add(elem);\r\n    }\r\n    return _union;\r\n}\r\n/**\r\n * returns difference of two sets\r\n */\r\nexport function difference(setA, setB) {\r\n    const _difference = new Set(setA);\r\n    for (const elem of setB) {\r\n        _difference.delete(elem);\r\n    }\r\n    return _difference;\r\n}\r\n", "import { BaseChain } from \"./base.js\";\r\nimport { intersection, union, difference } from \"../util/set.js\";\r\nfunction formatSet(input) {\r\n    return Array.from(input)\r\n        .map((i) => `\"${i}\"`)\r\n        .join(\", \");\r\n}\r\n/**\r\n * Chain where the outputs of one chain feed directly into next.\r\n */\r\nexport class SequentialChain extends BaseChain {\r\n    static lc_name() {\r\n        return \"SequentialChain\";\r\n    }\r\n    get inputKeys() {\r\n        return this.inputVariables;\r\n    }\r\n    get outputKeys() {\r\n        return this.outputVariables;\r\n    }\r\n    constructor(fields) {\r\n        super(fields);\r\n        Object.defineProperty(this, \"chains\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"inputVariables\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"outputVariables\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"returnAll\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        this.chains = fields.chains;\r\n        this.inputVariables = fields.inputVariables;\r\n        this.outputVariables = fields.outputVariables ?? [];\r\n        if (this.outputVariables.length > 0 && fields.returnAll) {\r\n            throw new Error(\"Either specify variables to return using `outputVariables` or use `returnAll` param. Cannot apply both conditions at the same time.\");\r\n        }\r\n        this.returnAll = fields.returnAll ?? false;\r\n        this._validateChains();\r\n    }\r\n    /** @ignore */\r\n    _validateChains() {\r\n        if (this.chains.length === 0) {\r\n            throw new Error(\"Sequential chain must have at least one chain.\");\r\n        }\r\n        const memoryKeys = this.memory?.memoryKeys ?? [];\r\n        const inputKeysSet = new Set(this.inputKeys);\r\n        const memoryKeysSet = new Set(memoryKeys);\r\n        const keysIntersection = intersection(inputKeysSet, memoryKeysSet);\r\n        if (keysIntersection.size > 0) {\r\n            throw new Error(`The following keys: ${formatSet(keysIntersection)} are overlapping between memory and input keys of the chain variables. This can lead to unexpected behaviour. Please use input and memory keys that don't overlap.`);\r\n        }\r\n        const availableKeys = union(inputKeysSet, memoryKeysSet);\r\n        for (const chain of this.chains) {\r\n            let missingKeys = difference(new Set(chain.inputKeys), availableKeys);\r\n            if (chain.memory) {\r\n                missingKeys = difference(missingKeys, new Set(chain.memory.memoryKeys));\r\n            }\r\n            if (missingKeys.size > 0) {\r\n                throw new Error(`Missing variables for chain \"${chain._chainType()}\": ${formatSet(missingKeys)}. Only got the following variables: ${formatSet(availableKeys)}.`);\r\n            }\r\n            const outputKeysSet = new Set(chain.outputKeys);\r\n            const overlappingOutputKeys = intersection(availableKeys, outputKeysSet);\r\n            if (overlappingOutputKeys.size > 0) {\r\n                throw new Error(`The following output variables for chain \"${chain._chainType()}\" are overlapping: ${formatSet(overlappingOutputKeys)}. This can lead to unexpected behaviour.`);\r\n            }\r\n            for (const outputKey of outputKeysSet) {\r\n                availableKeys.add(outputKey);\r\n            }\r\n        }\r\n        if (this.outputVariables.length === 0) {\r\n            if (this.returnAll) {\r\n                const outputKeys = difference(availableKeys, inputKeysSet);\r\n                this.outputVariables = Array.from(outputKeys);\r\n            }\r\n            else {\r\n                this.outputVariables = this.chains[this.chains.length - 1].outputKeys;\r\n            }\r\n        }\r\n        else {\r\n            const missingKeys = difference(new Set(this.outputVariables), new Set(availableKeys));\r\n            if (missingKeys.size > 0) {\r\n                throw new Error(`The following output variables were expected to be in the final chain output but were not found: ${formatSet(missingKeys)}.`);\r\n            }\r\n        }\r\n    }\r\n    /** @ignore */\r\n    async _call(values, runManager) {\r\n        let input = {};\r\n        const allChainValues = values;\r\n        let i = 0;\r\n        for (const chain of this.chains) {\r\n            i += 1;\r\n            input = await chain.call(allChainValues, runManager?.getChild(`step_${i}`));\r\n            for (const key of Object.keys(input)) {\r\n                allChainValues[key] = input[key];\r\n            }\r\n        }\r\n        const output = {};\r\n        for (const key of this.outputVariables) {\r\n            output[key] = allChainValues[key];\r\n        }\r\n        return output;\r\n    }\r\n    _chainType() {\r\n        return \"sequential_chain\";\r\n    }\r\n    static async deserialize(data) {\r\n        const chains = [];\r\n        const inputVariables = data.input_variables;\r\n        const outputVariables = data.output_variables;\r\n        const serializedChains = data.chains;\r\n        for (const serializedChain of serializedChains) {\r\n            const deserializedChain = await BaseChain.deserialize(serializedChain);\r\n            chains.push(deserializedChain);\r\n        }\r\n        return new SequentialChain({ chains, inputVariables, outputVariables });\r\n    }\r\n    serialize() {\r\n        const chains = [];\r\n        for (const chain of this.chains) {\r\n            chains.push(chain.serialize());\r\n        }\r\n        return {\r\n            _type: this._chainType(),\r\n            input_variables: this.inputVariables,\r\n            output_variables: this.outputVariables,\r\n            chains,\r\n        };\r\n    }\r\n}\r\n/**\r\n * Simple chain where a single string output of one chain is fed directly into the next.\r\n * @augments BaseChain\r\n * @augments SimpleSequentialChainInput\r\n *\r\n * @example\r\n * ```ts\r\n * import { SimpleSequentialChain, LLMChain } from \"langchain/chains\";\r\n * import { OpenAI } from \"langchain/llms/openai\";\r\n * import { PromptTemplate } from \"langchain/prompts\";\r\n *\r\n * // This is an LLMChain to write a synopsis given a title of a play.\r\n * const llm = new OpenAI({ temperature: 0 });\r\n * const template = `You are a playwright. Given the title of play, it is your job to write a synopsis for that title.\r\n *\r\n * Title: {title}\r\n * Playwright: This is a synopsis for the above play:`\r\n * const promptTemplate = new PromptTemplate({ template, inputVariables: [\"title\"] });\r\n * const synopsisChain = new LLMChain({ llm, prompt: promptTemplate });\r\n *\r\n *\r\n * // This is an LLMChain to write a review of a play given a synopsis.\r\n * const reviewLLM = new OpenAI({ temperature: 0 })\r\n * const reviewTemplate = `You are a play critic from the New York Times. Given the synopsis of play, it is your job to write a review for that play.\r\n *\r\n * Play Synopsis:\r\n * {synopsis}\r\n * Review from a New York Times play critic of the above play:`\r\n * const reviewPromptTemplate = new PromptTemplate({ template: reviewTemplate, inputVariables: [\"synopsis\"] });\r\n * const reviewChain = new LLMChain({ llm: reviewLLM, prompt: reviewPromptTemplate });\r\n *\r\n * const overallChain = new SimpleSequentialChain({chains: [synopsisChain, reviewChain], verbose:true})\r\n * const review = await overallChain.run(\"Tragedy at sunset on the beach\")\r\n * // the variable review contains resulting play review.\r\n * ```\r\n */\r\nexport class SimpleSequentialChain extends BaseChain {\r\n    static lc_name() {\r\n        return \"SimpleSequentialChain\";\r\n    }\r\n    get inputKeys() {\r\n        return [this.inputKey];\r\n    }\r\n    get outputKeys() {\r\n        return [this.outputKey];\r\n    }\r\n    constructor(fields) {\r\n        super(fields);\r\n        Object.defineProperty(this, \"chains\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"inputKey\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: \"input\"\r\n        });\r\n        Object.defineProperty(this, \"outputKey\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: \"output\"\r\n        });\r\n        Object.defineProperty(this, \"trimOutputs\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        this.chains = fields.chains;\r\n        this.trimOutputs = fields.trimOutputs ?? false;\r\n        this._validateChains();\r\n    }\r\n    /** @ignore */\r\n    _validateChains() {\r\n        for (const chain of this.chains) {\r\n            if (chain.inputKeys.filter((k) => !chain.memory?.memoryKeys.includes(k) ?? true).length !== 1) {\r\n                throw new Error(`Chains used in SimpleSequentialChain should all have one input, got ${chain.inputKeys.length} for ${chain._chainType()}.`);\r\n            }\r\n            if (chain.outputKeys.length !== 1) {\r\n                throw new Error(`Chains used in SimpleSequentialChain should all have one output, got ${chain.outputKeys.length} for ${chain._chainType()}.`);\r\n            }\r\n        }\r\n    }\r\n    /** @ignore */\r\n    async _call(values, runManager) {\r\n        let input = values[this.inputKey];\r\n        let i = 0;\r\n        for (const chain of this.chains) {\r\n            i += 1;\r\n            input = (await chain.call({ [chain.inputKeys[0]]: input, signal: values.signal }, runManager?.getChild(`step_${i}`)))[chain.outputKeys[0]];\r\n            if (this.trimOutputs) {\r\n                input = input.trim();\r\n            }\r\n            await runManager?.handleText(input);\r\n        }\r\n        return { [this.outputKey]: input };\r\n    }\r\n    _chainType() {\r\n        return \"simple_sequential_chain\";\r\n    }\r\n    static async deserialize(data) {\r\n        const chains = [];\r\n        const serializedChains = data.chains;\r\n        for (const serializedChain of serializedChains) {\r\n            const deserializedChain = await BaseChain.deserialize(serializedChain);\r\n            chains.push(deserializedChain);\r\n        }\r\n        return new SimpleSequentialChain({ chains });\r\n    }\r\n    serialize() {\r\n        const chains = [];\r\n        for (const chain of this.chains) {\r\n            chains.push(chain.serialize());\r\n        }\r\n        return {\r\n            _type: this._chainType(),\r\n            chains,\r\n        };\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;AAMO,SAAS,aAAa,MAAM,MAAM;AACrC,QAAM,gBAAgB,oBAAI,IAAI;AAC9B,aAAW,QAAQ,MAAM;AACrB,QAAI,KAAK,IAAI,IAAI,GAAG;AAChB,oBAAc,IAAI,IAAI;AAAA,IAC1B;AAAA,EACJ;AACA,SAAO;AACX;AAIO,SAAS,MAAM,MAAM,MAAM;AAC9B,QAAM,SAAS,IAAI,IAAI,IAAI;AAC3B,aAAW,QAAQ,MAAM;AACrB,WAAO,IAAI,IAAI;AAAA,EACnB;AACA,SAAO;AACX;AAIO,SAAS,WAAW,MAAM,MAAM;AACnC,QAAM,cAAc,IAAI,IAAI,IAAI;AAChC,aAAW,QAAQ,MAAM;AACrB,gBAAY,OAAO,IAAI;AAAA,EAC3B;AACA,SAAO;AACX;;;AChCA,SAAS,UAAU,OAAO;AACtB,SAAO,MAAM,KAAK,KAAK,EAClB,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EACnB,KAAK,IAAI;AAClB;AAIO,IAAM,kBAAN,MAAM,yBAAwB,UAAU;AAAA,EAC3C,OAAO,UAAU;AACb,WAAO;AAAA,EACX;AAAA,EACA,IAAI,YAAY;AACZ,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,IAAI,aAAa;AACb,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,YAAY,QAAQ;AAChB,UAAM,MAAM;AACZ,WAAO,eAAe,MAAM,UAAU;AAAA,MAClC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,kBAAkB;AAAA,MAC1C,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,mBAAmB;AAAA,MAC3C,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,aAAa;AAAA,MACrC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,SAAK,SAAS,OAAO;AACrB,SAAK,iBAAiB,OAAO;AAC7B,SAAK,kBAAkB,OAAO,mBAAmB,CAAC;AAClD,QAAI,KAAK,gBAAgB,SAAS,KAAK,OAAO,WAAW;AACrD,YAAM,IAAI,MAAM,qIAAqI;AAAA,IACzJ;AACA,SAAK,YAAY,OAAO,aAAa;AACrC,SAAK,gBAAgB;AAAA,EACzB;AAAA;AAAA,EAEA,kBAAkB;AAxDtB;AAyDQ,QAAI,KAAK,OAAO,WAAW,GAAG;AAC1B,YAAM,IAAI,MAAM,gDAAgD;AAAA,IACpE;AACA,UAAM,eAAa,UAAK,WAAL,mBAAa,eAAc,CAAC;AAC/C,UAAM,eAAe,IAAI,IAAI,KAAK,SAAS;AAC3C,UAAM,gBAAgB,IAAI,IAAI,UAAU;AACxC,UAAM,mBAAmB,aAAa,cAAc,aAAa;AACjE,QAAI,iBAAiB,OAAO,GAAG;AAC3B,YAAM,IAAI,MAAM,uBAAuB,UAAU,gBAAgB,CAAC,oKAAoK;AAAA,IAC1O;AACA,UAAM,gBAAgB,MAAM,cAAc,aAAa;AACvD,eAAW,SAAS,KAAK,QAAQ;AAC7B,UAAI,cAAc,WAAW,IAAI,IAAI,MAAM,SAAS,GAAG,aAAa;AACpE,UAAI,MAAM,QAAQ;AACd,sBAAc,WAAW,aAAa,IAAI,IAAI,MAAM,OAAO,UAAU,CAAC;AAAA,MAC1E;AACA,UAAI,YAAY,OAAO,GAAG;AACtB,cAAM,IAAI,MAAM,gCAAgC,MAAM,WAAW,CAAC,MAAM,UAAU,WAAW,CAAC,uCAAuC,UAAU,aAAa,CAAC,GAAG;AAAA,MACpK;AACA,YAAM,gBAAgB,IAAI,IAAI,MAAM,UAAU;AAC9C,YAAM,wBAAwB,aAAa,eAAe,aAAa;AACvE,UAAI,sBAAsB,OAAO,GAAG;AAChC,cAAM,IAAI,MAAM,6CAA6C,MAAM,WAAW,CAAC,sBAAsB,UAAU,qBAAqB,CAAC,0CAA0C;AAAA,MACnL;AACA,iBAAW,aAAa,eAAe;AACnC,sBAAc,IAAI,SAAS;AAAA,MAC/B;AAAA,IACJ;AACA,QAAI,KAAK,gBAAgB,WAAW,GAAG;AACnC,UAAI,KAAK,WAAW;AAChB,cAAM,aAAa,WAAW,eAAe,YAAY;AACzD,aAAK,kBAAkB,MAAM,KAAK,UAAU;AAAA,MAChD,OACK;AACD,aAAK,kBAAkB,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC,EAAE;AAAA,MAC/D;AAAA,IACJ,OACK;AACD,YAAM,cAAc,WAAW,IAAI,IAAI,KAAK,eAAe,GAAG,IAAI,IAAI,aAAa,CAAC;AACpF,UAAI,YAAY,OAAO,GAAG;AACtB,cAAM,IAAI,MAAM,oGAAoG,UAAU,WAAW,CAAC,GAAG;AAAA,MACjJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA,EAEA,MAAM,MAAM,QAAQ,YAAY;AAC5B,QAAI,QAAQ,CAAC;AACb,UAAM,iBAAiB;AACvB,QAAI,IAAI;AACR,eAAW,SAAS,KAAK,QAAQ;AAC7B,WAAK;AACL,cAAQ,MAAM,MAAM,KAAK,gBAAgB,yCAAY,SAAS,QAAQ,CAAC,GAAG;AAC1E,iBAAW,OAAO,OAAO,KAAK,KAAK,GAAG;AAClC,uBAAe,GAAG,IAAI,MAAM,GAAG;AAAA,MACnC;AAAA,IACJ;AACA,UAAM,SAAS,CAAC;AAChB,eAAW,OAAO,KAAK,iBAAiB;AACpC,aAAO,GAAG,IAAI,eAAe,GAAG;AAAA,IACpC;AACA,WAAO;AAAA,EACX;AAAA,EACA,aAAa;AACT,WAAO;AAAA,EACX;AAAA,EACA,aAAa,YAAY,MAAM;AAC3B,UAAM,SAAS,CAAC;AAChB,UAAM,iBAAiB,KAAK;AAC5B,UAAM,kBAAkB,KAAK;AAC7B,UAAM,mBAAmB,KAAK;AAC9B,eAAW,mBAAmB,kBAAkB;AAC5C,YAAM,oBAAoB,MAAM,UAAU,YAAY,eAAe;AACrE,aAAO,KAAK,iBAAiB;AAAA,IACjC;AACA,WAAO,IAAI,iBAAgB,EAAE,QAAQ,gBAAgB,gBAAgB,CAAC;AAAA,EAC1E;AAAA,EACA,YAAY;AACR,UAAM,SAAS,CAAC;AAChB,eAAW,SAAS,KAAK,QAAQ;AAC7B,aAAO,KAAK,MAAM,UAAU,CAAC;AAAA,IACjC;AACA,WAAO;AAAA,MACH,OAAO,KAAK,WAAW;AAAA,MACvB,iBAAiB,KAAK;AAAA,MACtB,kBAAkB,KAAK;AAAA,MACvB;AAAA,IACJ;AAAA,EACJ;AACJ;AAqCO,IAAM,wBAAN,MAAM,+BAA8B,UAAU;AAAA,EACjD,OAAO,UAAU;AACb,WAAO;AAAA,EACX;AAAA,EACA,IAAI,YAAY;AACZ,WAAO,CAAC,KAAK,QAAQ;AAAA,EACzB;AAAA,EACA,IAAI,aAAa;AACb,WAAO,CAAC,KAAK,SAAS;AAAA,EAC1B;AAAA,EACA,YAAY,QAAQ;AAChB,UAAM,MAAM;AACZ,WAAO,eAAe,MAAM,UAAU;AAAA,MAClC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,YAAY;AAAA,MACpC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,aAAa;AAAA,MACrC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,eAAe;AAAA,MACvC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,SAAK,SAAS,OAAO;AACrB,SAAK,cAAc,OAAO,eAAe;AACzC,SAAK,gBAAgB;AAAA,EACzB;AAAA;AAAA,EAEA,kBAAkB;AACd,eAAW,SAAS,KAAK,QAAQ;AAC7B,UAAI,MAAM,UAAU,OAAO,CAAC,MAAG;AAjO3C;AAiO8C,kBAAC,WAAM,WAAN,mBAAc,WAAW,SAAS;AAAA,OAAU,EAAE,WAAW,GAAG;AAC3F,cAAM,IAAI,MAAM,uEAAuE,MAAM,UAAU,MAAM,QAAQ,MAAM,WAAW,CAAC,GAAG;AAAA,MAC9I;AACA,UAAI,MAAM,WAAW,WAAW,GAAG;AAC/B,cAAM,IAAI,MAAM,wEAAwE,MAAM,WAAW,MAAM,QAAQ,MAAM,WAAW,CAAC,GAAG;AAAA,MAChJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA,EAEA,MAAM,MAAM,QAAQ,YAAY;AAC5B,QAAI,QAAQ,OAAO,KAAK,QAAQ;AAChC,QAAI,IAAI;AACR,eAAW,SAAS,KAAK,QAAQ;AAC7B,WAAK;AACL,eAAS,MAAM,MAAM,KAAK,EAAE,CAAC,MAAM,UAAU,CAAC,CAAC,GAAG,OAAO,QAAQ,OAAO,OAAO,GAAG,yCAAY,SAAS,QAAQ,CAAC,GAAG,GAAG,MAAM,WAAW,CAAC,CAAC;AACzI,UAAI,KAAK,aAAa;AAClB,gBAAQ,MAAM,KAAK;AAAA,MACvB;AACA,aAAM,yCAAY,WAAW;AAAA,IACjC;AACA,WAAO,EAAE,CAAC,KAAK,SAAS,GAAG,MAAM;AAAA,EACrC;AAAA,EACA,aAAa;AACT,WAAO;AAAA,EACX;AAAA,EACA,aAAa,YAAY,MAAM;AAC3B,UAAM,SAAS,CAAC;AAChB,UAAM,mBAAmB,KAAK;AAC9B,eAAW,mBAAmB,kBAAkB;AAC5C,YAAM,oBAAoB,MAAM,UAAU,YAAY,eAAe;AACrE,aAAO,KAAK,iBAAiB;AAAA,IACjC;AACA,WAAO,IAAI,uBAAsB,EAAE,OAAO,CAAC;AAAA,EAC/C;AAAA,EACA,YAAY;AACR,UAAM,SAAS,CAAC;AAChB,eAAW,SAAS,KAAK,QAAQ;AAC7B,aAAO,KAAK,MAAM,UAAU,CAAC;AAAA,IACjC;AACA,WAAO;AAAA,MACH,OAAO,KAAK,WAAW;AAAA,MACvB;AAAA,IACJ;AAAA,EACJ;AACJ;",
  "names": []
}
